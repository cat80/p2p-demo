## 深入理解异步编程(python)

#### 目标：
为了深入学习和理解异步编程，有必要对异步编程相关的知识，做一些基础、系统、整体的整理。在使用异步编程的时候，不仅仅要明白怎么用，而且要明白为什么这样用。


### 1. 异步编程概念的认知。

在开始研究异步编程前，有必要回顾一下操作系统的基本概念。

1. 应用程序
   即系统以外可运行的程序，程序本质上就是一个受操作系统调度，能访问本地资源（内在、磁盘、CPU、网络 等）的第三方应用。不管是汇编机器码，还是是C/C++/go编译好的汇编，还是java/c#编译的中间语言，或者像python/php/nodejs的脚本代码，都可以说是应用程序。只是他们直接的方式不一样，像汇编是操作系统直接加载执行的，不再需要额外的运行环境了。C/C++/GO编译好的汇编理论上和直接写的汇编是一样的，当然程序有一些可能动态链接库需要环境支持，不过很多程序会把他们打包成静态连接库，不过由说不同操作系统和CPU架构的差别，所以针对不同平台，需要编辑不 同的汇编，但原理都是一样的。而中间语言则需要运行时的支持（比如jvm,.net clr)，由运行行再来加载已经编译好的中间语言来执行。而脚本语言，在执行前一般为纯文本。在执行过程中，本质上是启动脚本解析器（如cpython或者node)，然后传入入口脚本文件的路径开始执行。所以我们能看到node xx.js,python xx.py前面的node,python就是脚本解析器。

  这里面再对比一下三类程语言的优缺点。
   - 汇编：这个是操作系统最底层最直接的语言。你用最直接的方式操作内存、CPU等资源，执行效率最高。但同样的问题就是，编写起来很麻烦，你要申请、销毁、维护几乎程序中的每一个内存的地址，很容易内存先泄漏，甚至使系统崩溃。汇编编写十分困难开发效率非常低，而且程序运行也不够稳定性。而且针对不同操作系统和不同架构的CPU，汇编代码几乎不可用，需要重写一套。一般汇编都是用来编写驱动，或底层对性能有极致要求的系统程序（不过现在操作系统绝大部分也不直接用汇编写了）
   - c/c++/go 。这类我们一般也称编译型语言，主要就是为了解决，汇编语言存在的那些问题出来的。工作原理是由编译器，把相关的语言代码转化成特定平台的可直接执行的汇编代码。这类语言由于最终编译出来的就是汇编，所以在执行效率上和几乎汇编是一样的。而且，编辑器可以做一些优化，在某些时间可能比直接写汇编有更快的执行效率。而且带来了更高的表达能力（如变量，流程控制，模块化利用等），跨平台编译能力（做很小的变化就能使代码编辑到不同操作和架构和CPU上去运行），同时在健壮上也有了非常大的提升。可以说编辑型语言和汇编比，几乎全部是优点，而惟一的缺点毕竟是封装了一层，相对说汇编来说会缺乏一点点灵活性。但同于编辑型语言也同样能直接操作内存，也会带来内存泄漏和安全的问题。
   - java/c#。这一种语言我们也一般称为虚拟机语言，由说代码是说运行时托管执行的，我们也会称这些语言为托管语言。这类语言的运行原理是，java或者c#代码，由对应的编辑器先编译成某种中间语言，这种语言和汇编类似，能快速的得到解析，但是不能直接被操作系统执行的。在执行的前，会先加载运行时环境，把中间语言交给运行时去解释运行（把中间语言再转换成机器码）。这种语言，看起来有点多些一举，因为理论上他们也完全可以直接编译成机器码去执行。但这个看似多些一举的行为却带了两个非常大的好处，一个就是因为有运行时的存在，内存完全会由运行时来管理，所以在上层根本不需要考虑内存安全的问题，只管随便用就好了，剩下的由运行时来管理。而且，这类语言往往能提供更高的表达能力，能进一步提升开发效果。同时，由于编译出来的是中间代码，由运行时在特定的系统+CPU解析本地可执行的汇编，在跨平台上就会有非常大的优势，几乎不要考虑平台的差异，代码都能完整的运行。当然，这类语言最大的问题就是在运行时的内在管理（也就是所谓的GC），虽然GC算法在不断的优化更新，但在GC工作的时候不可避免的会造成整个程序性能的中断，这对很多程序是完全不能接触的。不过，很多人觉得中间语言需要运行时来解析运行，在代码执行效率上会远远慢于编译语言，这其它是一个很大的误解。因为，运行时一帮只有在第一次运行程序的时候，才会把中间语言翻译成本地汇编，后来的执行过程中会直接执行编辑好的机器码（这个技术叫JIT），在运行性能上（特别是第一次）会有一些差异，但整体不是特别大。
   - python/node/js. 这类我们一般称为解释器型语言或者脚本语言。这类语言一般根本不需要编译（尽管解析器在执行的时候，一般还是会把代码转换成操作码op_code)，是以纯文本的形式由解释器来执行。这样做的好处就是由于代码
2. 
操作系统在执行应用时，会给应用分配相关的资源（如：内存、cpu执行时间、网络等），这也是我们所说的 *进程*。

